---
{"제목":"전역 상태 관리 라이브러리","날짜":"2025-05-29","tags":["매일메일"],"dg-publish":true,"permalink":"/매일메일/25년5월/전역 상태 관리 라이브러리/","dgPassFrontmatter":true,"created":"2025-05-30T03:16:17.991+09:00","updated":"2025-05-30T03:24:24.188+09:00"}
---

## ❓질문

전역 상태 관리 라이브러리는 왜 사용하나요?

---
## 💡 조사하기전 내가 알고 있던 내용

내가 마이크로 상태 관리라는 책을 읽고 드는 생각이 있는데 단순하게 `props drilling`을 막기 위해서 쓰임도 있지만 `Context API`를 활용한 상태 관리에는 불필요한 리렌더링이 발생할 수 도 있기때문에 최적화를 위한 코드도 작성해줘야하고 다소 비용이 많이 든다.

그때문에 전역 상태 관리 라이브러리를 도입해 비용을 줄이고 각 라이브러리 마다 주는 부가적인 기능등을 통해서 보다 쉽게 상태를 관리 하고 코스트를 줄일 수 있다.
ex)zustand의 `persist middleware`

---
## 🏫 정리한 내용

첫째, **컴포넌트 간 상태 공유가 용이해집니다**. 여러 컴포넌트에서 공통적으로 사용되는 상태를 중앙화하여 관리하고, 여러 곳에서 쉽게 접근할 수 있습니다. 부모 컴포넌트에서 자식 컴포넌트에게 상태를 전달하기 위해 여러 컴포넌트를 거치는 "props drilling"을 겪지 않고 상태를 공유할 수 있습니다.

둘째, **관심사 분리가 용이해집니다**. 상태 관리 로직을 컴포넌트에서 분리하여 별도로 관리함으로써, 컴포넌트는 UI 로직에만 집중할 수 있게 됩니다. 예를 들어 Redux에서는 상태 변경 로직을 Reducer에 정의해두고, 컴포넌트 단에서는 Dispatch를 통해 Reducer를 호출하는 방식으로 동작합니다. 이러한 분리는 "관심사의 분리 원칙"을 따르며 코드 재사용성과 테스트 용이성을 높여줍니다.

셋째, **성능 최적화에 도움이 됩니다**. 현대의 상태 관리 라이브러리들은 불필요한 리렌더링을 방지하는 메커니즘을 제공합니다. 예를 들어 Zustand는 구독 메커니즘을 통해 실제로 상태가 변경된 컴포넌트만 리렌더링되도록 보장합니다.

결국 어떠한 라이브러리를 도입한다는건 그 만큼 번들 사이즈는 늘어난다. 즉 사이즈가 늘어난 만큼 이 라이브러리를 도입했을때 얼마나 성능상승,비용절감의 효과가 있는지 고민하고 도입해보자
규모가 작은 프로젝트의 경우 충분히 `useState`와 `Context API`등으로 커버될 것이다.